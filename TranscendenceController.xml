<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Thursday, December 15, 2022, 10:39 PM -->
<!-- MuClient version 5.07-pre -->

<!-- Plugin "TranscendenceController" generated by Plugin Wizard -->

<muclient>
<plugin
   name="TranscendenceController"
   author="Athlau"
   id="a22539a131e3db5919ee04cc"
   language="Lua"
   purpose="Simplify controller's task in P3: Divinity's Siege"
   save_state="y"
   date_written="2022-12-15 22:33:17"
   requires="5.07"
   version="1.0"
   >
<description trim="y">
<![CDATA[
Bla bla bla, add more text here
TC commands:
  tc_help - this help
  tc_map - sends 'map' command and parses output to a miniwindow
  tc_show - show miniwindow
  tc_options [set <group> <key> <value>] - shows or sets plugin option(s), for example:
    tc_options - show all options
    tc_options set auto_map enable false - disable automatic sending of 'map' command
    tc_options set font size 20 - set window font size to 20
    tc_options set mouse_actions ctrl+alt+shift+middle echo I'm amazing;;echo that's lots of keys
      - performs echo commands when a middle mouse button is clicked on a cell while pressing ctrl, alt, shift keys
      - Note: cell column/row is added to the end of command line
      - Note: available mouse actions are [ctrl+][alt+][shift+](left|right|middle)
    tc_options set style xx_border_color 13158600 - change cell outline color for rooms with XX mobs to white
      - Note: use "LUA" value from mush client color picker (ctrl+alt+P) tool to get the color you want
  tc_on - enable controller auto functions
  tc_off - disable controller auto functions
  tc_test - show miniwindow with test data capture
]]>
</description>

</plugin>


<!--  Aliases  -->

<aliases>
  <alias
   script="tcOnHelp"
   match="tc_help"
   enabled="y"
  >
  </alias>

  <alias
   script="tcOnMapCmd"
   match="tc_map"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  </alias>

  <alias
   script="tcOnShowCmd"
   match="tc_show"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  </alias>

  <alias
   script="tcOnOffCmd"
   match="tc_off"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  </alias>

  <alias
   script="tcOnOnCmd"
   match="tc_on"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  </alias>

  <alias
   script="tcOnOptionsCmd"
   match="^tc_options(?: set (?<key1>[^\s]+) (?<key2>[^\s]+) (?<value>.+)|)$"
   regexp="y"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  </alias> 

  <alias
   script="tcOnTestCmd"
   match="tc_test"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  </alias>
</aliases>

<!--  Timers  -->
<timers>
  <timer name="auto_map_timer" enabled="n" second="3" offset_second="0.0" send_to="10">
   <send>tc_map</send>
  </timer>
</timers>

<!--  Triggers  -->

<triggers>
  <trigger
   enabled="n"
   group="capture_map_command"
   keep_evaluating="y"
   lines_to_match="2"  
   match="^(?<row>\d) \|\[(?:\s?(?<aWW>\d+)\+\s?(?<aXX>\d+)\s+|\s+)[\| ]?\[(?:\s?(?<bWW>\d+)\+\s?(?<bXX>\d+)\s+|\s+)[\| ]?\[(?:\s?(?<cWW>\d+)\+\s?(?<cXX>\d+)\s+|\s+)\|.*\n\1 \|(?<aObs>\*| )(?:\s?(?<aYY>\d+)\+\s?(?<aZZ>\d+)|\s+)\](?: |\|)(?<bObs>\*| )(?:\s?(?<bYY>\d+)\+\s?(?<bZZ>\d+)|\s+)\](?: |\|)(?<cObs>\*| )(?:\s?(?<cYY>\d+)\+\s?(?<cZZ>\d+)|\s+)\]\|.*\Z"
   multi_line="y"
   regexp="y"
   script="tcHandleMapLine"
   sequence="2"
   omit_from_output="y"
  >
  </trigger>
  <trigger
   enabled="n"
   group="map_command_gag"
   keep_evaluating="y"
   match="^(?<row>\d) \|\[(?:\s?(?<aWW>\d+)\+\s?(?<aXX>\d+)\s+|\s+)[\| ]?\[(?:\s?(?<bWW>\d+)\+\s?(?<bXX>\d+)\s+|\s+)[\| ]?\[(?:\s?(?<cWW>\d+)\+\s?(?<cXX>\d+)\s+|\s+)\|.*$"
   regexp="y"
   script=""
   sequence="2"
   omit_from_output="y"
  >
  <send></send>
  </trigger>
  <trigger
   enabled="n"
   group="map_command_gag"
   keep_evaluating="y"
   match="^(?<row>\d) \|(?<aObs>\*| )(?:\s?(?<aYY>\d+)\+\s?(?<aZZ>\d+)|\s+)\](?: |\|)(?<bObs>\*| )(?:\s?(?<bYY>\d+)\+\s?(?<bZZ>\d+)|\s+)\](?: |\|)(?<cObs>\*| )(?:\s?(?<cYY>\d+)\+\s?(?<cZZ>\d+)|\s+)\]\|.*$"
   regexp="y"
   script=""
   sequence="2"
   omit_from_output="y"
  >
  <send></send>
  </trigger>
  <trigger
   enabled="n"
   group="map_command_gag"
   keep_evaluating="y"
   match="^\s+-----------------------\s*(?:Key: \[WW\+XX\s?)?$"
   regexp="y"
   script=""
   sequence="2"
   omit_from_output="y"
  >
  <send></send>
  </trigger>
  <trigger
   enabled="n"
   group="map_command_gag"
   keep_evaluating="y"
   match="^\s+A       B       C\s?$"
   regexp="y"
   script="tcHandleMapEnd"
   sequence="2"
   omit_from_output="y"
  >
  <send></send>
  </trigger>
</triggers>

<!--  Script  -->

<script>
<![CDATA[
require "var"
require "serialize"
require "themed_miniwindows"
require "tprint"

local tc_options = {}
local map = {}
local window = nil
local font = nil
local tc_enabled = false

function tcGetDefaultOptions()
  local default_options = {
    auto_map = {
      enabled = true,
      period = 3,
      gag_output = true,
    },
    style = {
      cells_offset_left = 20,
      text_padding = 3,
      text_cell_line_padding = 10,
      cell_padding_x = 4,
      cell_padding_y = 4,
      cell_conn_width = 20,
      cell_conn_height = 15,
      -- BGR
      text_color = 0xc8c8c8,
      bg_color = 0x333333,
      ww_color = 0x00ffff,
      xx_color = 0x0000ff,
      xx_border_color = 0x0000ff,
      yy_color = 0x00ff00,
      zz_color = 0xff4444,
      obs_color = 0xEE00EE,
    },
    font = {
      name = "Courier",
      size = 10,
      bold = true,
    },
    mouse_actions = {
      ["right"] = "echo observe",
      ["shift+right"] = "echo report bad",
      ["middle"] = "echo advance",
      ["left"] = "echo say acid",
      ["shift+left"] = "echo say water",
      ["alt+left"] = "echo say lightning",
    },
  }
  return default_options
end

function tcCheckOptions()
  -- Do nothing for now
end

function tcLoadOptions()
  tc_options = loadstring(string.format("return %s", var.config or serialize.save_simple(tcGetDefaultOptions())))()
  -- TEMP
  -- tc_options = loadstring(string.format("return %s", serialize.save_simple(tcGetDefaultOptions())))()
  tcCheckOptions()
  tcSaveOptions()
end

function tcSaveOptions()
  var.config = serialize.save_simple(tc_options)
end

------ Map related code ------
function tcExecuteMapCommand()
  map = {}
  EnableTriggerGroup("capture_map_command", 1)
  EnableTriggerGroup("map_command_gag", tc_options.auto_map.gag_output)
  SendNoEcho("map")
end

function tcHandleMapLine(name, line, wildcards)
  local row = {}
  row[1] = { observed = wildcards.aObs == "*" or false,
             WW = wildcards.aWW,
             XX = wildcards.aXX,
             YY = wildcards.aYY,
             ZZ = wildcards.aZZ,
           }
  row[2] = { observed = wildcards.bObs == "*" or false,
             WW = wildcards.bWW,
             XX = wildcards.bXX,
             YY = wildcards.bYY,
             ZZ = wildcards.bZZ,
           }
  row[3] = { observed = wildcards.cObs == "*" or false,
             WW = wildcards.cWW,
             XX = wildcards.cXX,
             YY = wildcards.cYY,
             ZZ = wildcards.cZZ,
           }
  map[tonumber(wildcards.row)] = row
end

function tcHandleMapEnd(name, line, wildcards)
  EnableTriggerGroup("capture_map_command", 0)
  EnableTriggerGroup("map_command_gag", 0)
  tcWindowRedraw()
end

------ Window functions ------

function tcGetCellSize()
  --local font = WindowFontList(window.id)[1]
  local max_text = "88  88"
  return WindowTextWidth(window.id, font, max_text, false) + 2 * tc_options.style.text_padding,
         2 * WindowFontInfo(window.id, font, 1) +
         2 * tc_options.style.text_padding + tc_options.style.text_cell_line_padding
end

function tcDrawCell(row, col)
  --local font = WindowFontList(window.id)[1]
  local width, height = tcGetCellSize()
  local left = window.bodyleft + tc_options.style.cells_offset_left +
               tc_options.style.cell_padding_x * (col -1) + width * (col - 1)
  local top = window.bodytop + tc_options.style.cell_padding_y * (9 - row) + height * (9 - row)
  local right = left + width
  local bottom = top + height

  -- Draw rect  
  WindowRectOp(window.id, 2, left + 1, top + 1, right - 1, bottom - 1, tc_options.style.bg_color)
  local outline_color = (map[row][col].XX ~= "" and map[row][col].XX ~= "0")
                        and tc_options.style.xx_border_color or tc_options.style.text_color
  WindowRectOp(window.id, 1, left, top, right, bottom, outline_color)

  -- Draw text
  if map[row][col].WW ~= "0" then
    WindowText(window.id, font, map[row][col].WW, left + tc_options.style.text_padding,
               top + tc_options.style.text_padding,
               right, bottom, tc_options.style.ww_color, false)
  end

  if map[row][col].XX ~= "0" then
    local text_width = WindowTextWidth(window.id, font, map[row][col].XX, false)
    WindowText(window.id, font, map[row][col].XX, 
               right - tc_options.style.text_padding - text_width,
               top + tc_options.style.text_padding,
               right, bottom, tc_options.style.xx_color, false)
  end

  if map[row][col].YY ~= "0" then
    WindowText(window.id, font, map[row][col].YY, left + tc_options.style.text_padding,
               top + tc_options.style.text_padding + WindowFontInfo(window.id, font, 1) +
                 tc_options.style.text_cell_line_padding,
               right, bottom, tc_options.style.yy_color, false)
  end

  if map[row][col].ZZ ~= "0" then
    local text_width = WindowTextWidth(window.id, font, map[row][col].ZZ, false)
    WindowText(window.id, font, map[row][col].ZZ, right - tc_options.style.text_padding - text_width,
               top + tc_options.style.text_padding + WindowFontInfo(window.id, font, 1) +
                 tc_options.style.text_cell_line_padding,
               right, bottom, tc_options.style.zz_color, false)
  end

  if map[row][col].observed then
    local text_width = WindowTextWidth(window.id, font, "*", false)
    WindowText(window.id, font, "*", left + (width - text_width) / 2,
               top + (height - WindowFontInfo(window.id, font, 1)) / 2,
               right, bottom, tc_options.style.obs_color, false)
  end
end

function tcGetTooltip()
  result = ""
  for key, val in pairs(tc_options.mouse_actions) do
    if result ~= "" then
      result = result.."\n"
    end
    result = result..key.." click => "..val
  end
  return result
end

function tcDrawStatic()
  local width, height = tcGetCellSize()

  for row = 0, 9, 1 do
    local top = window.bodytop + tc_options.style.cell_padding_y * (9 - row) + height * (9 - row)
    local bottom = top + height

    -- Draw row number
    local text_width = WindowTextWidth(window.id, font, tostring(row), false)
    WindowText(window.id, font, tostring(row), window.bodyleft + (tc_options.style.cells_offset_left - text_width) / 2,
               top + (height - WindowFontInfo(window.id, font, 1)) / 2,
               window.bodyleft + (tc_options.style.cells_offset_left + text_width) / 2,
               top + (height + WindowFontInfo(window.id, font, 1)) / 2, tc_options.style.text_color, false)

    for col = 1, 3, 1 do
      local left = window.bodyleft + tc_options.style.cells_offset_left +
                   tc_options.style.cell_padding_x * (col -1) + width * (col - 1)
      local right = left + width

      -- Draw connections to next cells
      if col ~= 3 and (row == 9 or row == 7 or row == 4 or row == 0) then
        WindowRectOp(window.id, 2, right - 1, top + (height - tc_options.style.cell_conn_height) / 2,
                     right + tc_options.style.cell_padding_x + 1,
                     top + (height + tc_options.style.cell_conn_height) / 2, tc_options.style.bg_color)
      end
      if row ~= 0 then
        WindowRectOp(window.id, 2, left + (width - tc_options.style.cell_conn_width) / 2, bottom - 1,
                     left + (width + tc_options.style.cell_conn_width) / 2,
                     bottom + tc_options.style.cell_padding_y + 1, tc_options.style.bg_color)
      end

      -- Draw col number
      if row == 0 then
        local text = col == 1 and "A" or (col == 2 and "B" or "C")
        local text_width = WindowTextWidth(window.id, font, text, false)
        WindowText(window.id, font, text, left + (width - text_width) / 2, bottom + tc_options.style.text_padding,
                   left + (width + text_width) / 2,
                   bottom + tc_options.style.text_padding + WindowFontInfo(window.id, font, 1), 
                   tc_options.style.text_color, false)
      end

      -- Add/move hotspots
      cell_id = (col == 1 and "a" or (col == 2 and "b" or "c")) .. tostring(row)
      if WindowMoveHotspot(window.id, cell_id, left, top, right, bottom) ~= 0 then
        WindowAddHotspot(window.id, cell_id, left, top, right, bottom,
                         nil, nil, nil, nil, "tcOnCellMouseUp",
                         tcGetTooltip(),
                         miniwin.cursor_plus, -- cursor
                         0  -- flags
                        )
      end
    end
  end
end

function tcWindowRedraw()
  window:blank()
  for row = 0, 9, 1 do
    for col = 1, 3, 1 do
      if map[row] ~= nil and map[row][col] ~= nil then
        tcDrawCell(row, col)
      end
    end
  end
  tcDrawStatic()
  window:dress_window()
end

function tcShowWindow()
  if window == nil then
    window = ThemedBasicWindow("tcWindow", 100, 100, 223, 520, "TC", "center", true, 1, tcWindowRedraw, tcWindowRedraw, tcOnWindowDelete)
    font = "tc_font"
    WindowFont(window.id, font, tc_options.font.name, tc_options.font.size, tc_options.font.bold,
               false, false, false, 0, 0)  -- bold
  end
  window:show()
  tcWindowRedraw()
end

function tcOnWindowDelete()
  window = nil
  font = nil
end

function tcOnCellMouseUp(flags, hotspot_id)
  if (tc_options.mouse_actions[tcMouseFlagsToName(flags)] ~= nil) then
    Execute(tc_options.mouse_actions[tcMouseFlagsToName(flags)].." "..hotspot_id)
  else
    Note("Warn: no action assigned for "..tcMouseFlagsToName(flags).. " click")
  end
end

------ Mouse buttons helpers -------
function tcMouseFlagsToName(flags)
  local result = ""
  if bit.band(flags, miniwin.hotspot_got_control) ~= 0 then
    result = result.."ctrl+"
  end
  if bit.band(flags, miniwin.hotspot_got_alt) ~= 0 then
    result = result.."alt+"
  end
  if bit.band(flags, miniwin.hotspot_got_shift) ~= 0 then
    result = result.."shift+"
  end
  if bit.band(flags, miniwin.hotspot_got_lh_mouse) ~= 0 then
    result = result.."left"
  end
  if bit.band(flags, miniwin.hotspot_got_rh_mouse) ~= 0 then
    result = result.."right"
  end
  if bit.band(flags, miniwin.hotspot_got_middle_mouse) ~= 0 then
    result = result.."middle"
  end
  return result
end

function tcNameToMouseFlags(name)
  local result = 0
  local re = rex.new("^(?<ctrl>ctrl\\+)?(?<alt>alt\\+)?(?<shift>shift\\+)?(?<button>left|right|middle)$")
  local s, e, captures = re:match(name)
  if s ~= nil then
    result = result + (captures.ctrl and miniwin.hotspot_got_control or 0)
    result = result + (captures.alt and miniwin.hotspot_got_alt or 0)
    result = result + (captures.shift and miniwin.hotspot_got_shift or 0)
    result = result + (captures.button == "left" and miniwin.hotspot_lh_mouse or 0)
    result = result + (captures.button == "right" and miniwin.hotspot_rh_mouse or 0)
    result = result + (captures.button == "middle" and miniwin.hotspot_middle_mouse or 0)
  else
    Note("Warn: incorrect mouse flags ["..name.."]")
  end
  return result
end

------ Console commands ------
function tcOnMapCmd()
  tcExecuteMapCommand()
end

function tcOnShowCmd()
  tcShowWindow()
end

function tcOnOffCmd()
  tc_enabled = false
  SetTimerOption("auto_map_timer", "enabled", false)
  if window then window:delete(false) end
end

function tcOnOnCmd()
  tc_enabled = on
  if tc_options.auto_map.enabled then
    SetTimerOption("auto_map_timer", "second", tc_options.auto_map.period)
    SetTimerOption("auto_map_timer", "enabled", true)
  end
  tcShowWindow()
end

function tcOnOptionsCmd(name, line, wildcards)
  Note("TC Options:")
  if wildcards.key1 == "" then
    tprint(tc_options)
  else
    if tc_options[wildcards.key1] == nil then
      Note("Warn: unknown option group "..wildcards.key1)
    end
    if tc_options[wildcards.key1][wildcards.key2] == nil then
      Note("Warn: unknown option "..wildcards.key2)
    end

    local type = type(tc_options[wildcards.key1][wildcards.key2])
    if type == "boolean" then
      local bool = wildcards.value == "true" and true or nil
      if wildcards.value == "false" then
        bool = false
      end
      if bool ~= nil then
        tc_options[wildcards.key1][wildcards.key2] = bool
        Note("Set "..wildcards.key1.." "..wildcards.key2.." to "..tostring(tc_options[wildcards.key1][wildcards.key2]))
      else
        Note(wildcards.value.." is not a valid boolean")
      end
    elseif type == "number" then
      if tonumber(wildcards.value) ~= nil then
        tc_options[wildcards.key1][wildcards.key2] = tonumber(wildcards.value)
        Note("Set "..wildcards.key1.." "..wildcards.key2.." to "..tostring(tc_options[wildcards.key1][wildcards.key2]))
      else
        Note(wildcards.value.." is not a valid number")
      end
    elseif type == "string" then
      tc_options[wildcards.key1][wildcards.key2] = wildcards.value
      Note("Set "..wildcards.key1.." "..wildcards.key2.." to "..tostring(tc_options[wildcards.key1][wildcards.key2]))
    end
    if wildcards.key1 == "font" or wildcards.key1 == "style" then
      if window then window:delete(false) end
      tcShowWindow()
    elseif wildcards.key1 == "auto_map" then
      if tc_enabled then
        tcOnOnCmd()
      end
    end
  end
end

function tcOnTestCmd()
  local test = [[
   -----------------------  Key: [WW+XX
9 |[ 4+ 0  [ 4+ 0  [ 4+ 0 |      YY+ZZ ]
9 |      ]       ]       ]| WW: Angel soldiers
8 |[ 4+ 0 |[ 4+ 0 |[ 4+ 0 | XX: Others
8 |      ]|      ]|      ]| YY: Players
7 |[ 5+ 0  [10+ 0  [ 6+ 0 | ZZ: Titans
7 |      ]       ]       ]|  * You can observe a room
6 |[ 4+ 1 |[ 4+ 0 |[ 4+ 0 |
6 |  1+ 0]|      ]|      ]|
5 |[ 4+ 0 |[      |[ 4+ 0 |
5 |  7+ 1]|  5+ 0]|  7+ 5]|
4 |[       [       [      |
4 |      ] * 1+ 1]       ]|
3 |[      |[      |[      |
3 |  0+ 3]|  0+ 3]|  0+ 3]|
2 |[      |[      |[      |
2 |      ]|      ]|      ]|
1 |[12+13 |[      |[      |
1 | 10+15]|      ]|      ]|
0 |[       [       [      |
0 |      ]       ]       ]|
   -----------------------
      A       B       C
]]
  tcShowWindow()
  Execute("tc_map")
  Simulate(test)
end

------ Plugin Callbacks ------
function tcOnHelp()
  world.Note(world.GetPluginInfo(world.GetPluginID(), 3))
end

function OnPluginInstall()
  tcOnHelp()
  OnPluginEnable()
end

function OnPluginEnable()
  tcLoadOptions()
  tcShowWindow()
end

function OnPluginConnect()
  tcLoadOptions()
end

function OnPluginDisable()
end

function OnPluginSaveState()
  tcSaveOptions()
end
]]>
</script>

</muclient>
