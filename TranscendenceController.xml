<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Thursday, December 15, 2022, 10:39 PM -->
<!-- MuClient version 5.07-pre -->

<!-- Plugin "TranscendenceController" generated by Plugin Wizard -->

<muclient>
<plugin
   name="TranscendenceController"
   author="Athlau"
   id="a22539a131e3db5919ee04cc"
   language="Lua"
   purpose="Simplify controller's task in P3: Divinity's Siege"
   save_state="y"
   date_written="2022-12-15 22:33:17"
   requires="5.07"
   version="1.0"
   >
<description trim="y">
<![CDATA[
Bla bla bla, add more text here
TC commands:
  tc_help - this help
  tc_map - sends 'map' command and parses output to a miniwindow
  tc_show - show miniwindow
  tc_options [set <group> <key> <value>] - shows or sets plugin option(s), for example:
    tc_options - show all options
    tc_options set auto_map enable false - disable automatic sending of 'map' command
    tc_options set font size 20 - set window font size to 20
    tc_options set mouse_actions ctrl+alt+shift+middle echo I'm amazing;;echo that's lots of keys
      - performs echo commands when a middle mouse button is clicked on a cell while pressing ctrl, alt, shift keys
      - Note: %col and %row in command will be replaced with clicked column/row
          For example: set mouse_actions right observe %col%row
      - Note: available mouse actions are [ctrl+][alt+][shift+](left|right|middle)
      - Note: set value to "clear" to remove mouse action, like
              set mouse_actions ctrl+alt+shift+middle clear
    tc_options set style xx_border_color 13158600 - change cell outline color for rooms with XX mobs to white
      - Note: use "LUA" value from mush client color picker (ctrl+alt+P) tool to get the color you want
    tc_options set misc observe_data_validity 5
      - tc_report_bad/tc_report_players will *first* issue an observe command if room was never observed or
      - observed more than specified number of seconds ago.
      - Note: should be set to 1 or more
  tc_options reset - reset options to defaults
  tc_on - enable controller auto functions
  tc_off - disable controller auto functions
  tc_gt - tells to group chat prepending group_tell_prefix from options
  tc_observe <room> - observe given room and capture output, tc_observe a1
  tc_report_bad <channel> <room> - observe and report bad mobs (if any) in given room, tc_report_bad tc_gt a1
  tc_report_players <channel> <room> - observe and report players health in given room, tc_report_players echo a1
  tc_report_cd <channel> - report cooldowns
  <acid|water|lightning> <room> - perform relevant action on given room
     - Note: those will work only if plugin is in ON state (tc_on)
  tc_test - show miniwindow with test data capture
  tc_test_observe <room> - show miniwindow with test observe data capture
  tc_test_cd - test cooldowns capture
]]>
</description>

</plugin>

<!--  Aliases  -->

<aliases>
  <alias
   script="tcOnHelp"
   match="tc_help"
   enabled="y"
  >
  </alias>
  <alias
   script="tcOnMapCmd"
   match="tc_map"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  </alias>
  <alias
   script="tcOnObserveCmd"
   match="^tc_observe (?<col>[a-c])(?<row>\d)$"
   regexp="y"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  </alias>
  <alias
   name = "water"
   group = "tc_actions"
   script="tcOnActionCmd"
   match="^water (?<col>[a-c])(?<row>\d)$"
   regexp="y"
   enabled="n"
   send_to="12"
   sequence="100"
  >
  </alias>
  <alias
   name = "acid"
   group = "tc_actions"
   script="tcOnActionCmd"
   match="^acid (?<col>[a-c])(?<row>\d)$"
   regexp="y"
   enabled="n"
   send_to="12"
   sequence="100"
  >
  </alias>
  <alias
   name = "lightning"
   group = "tc_actions"
   script="tcOnActionCmd"
   match="^lightning (?<col>[a-c])(?<row>\d)$"
   regexp="y"
   enabled="n"
   send_to="12"
   sequence="100"
  >
  </alias>
  <alias
   script="tcOnReportBadCmd"
   match="^tc_report_bad (?<channel>\w+) (?<col>[a-c])(?<row>\d)$"
   regexp="y"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  </alias>
  <alias
   script="tcOnReportPlayersCmd"
   match="^tc_report_players (?<channel>\w+) (?<col>[a-c])(?<row>\d)$"
   regexp="y"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  </alias>
  <alias
   script="tcOnReportCDCmd"
   match="^tc_report_cd (?<channel>\w+)$"
   regexp="y"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  </alias>
  <alias
   script="tcOnShowCmd"
   match="tc_show"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  </alias>
  <alias
   script="tcOnOffCmd"
   match="tc_off"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  </alias>
  <alias
   script="tcOnOnCmd"
   match="tc_on"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  </alias>
  <alias
   script="tcOnGtCmd"
   match="^tc_gt(?<message>.+)$"
   regexp="y"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  </alias>
  <alias
   script="tcOnOptionsCmd"
   match="^tc_options(?: set (?<key1>[^\s]+) (?<key2>[^\s]+) (?<value>.+)|)$"
   regexp="y"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  </alias> 
  <alias
   script="tcOnOptionsResetCmd"
   match="^tc_options reset$"
   regexp="y"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  </alias> 
  <alias
   script="tcOnTestCmd"
   match="tc_test"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  </alias>
  <alias
   script="tcOnTestObserveCmd"
   match="^tc_test_observe (?<col>[a-c])(?<row>\d)$"
   regexp="y"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  </alias>
  <alias
   script="tcOnTestCdCmd"
   match="^tc_test_cd$"
   regexp="y"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  </alias>
</aliases>

<!--  Timers  -->
<timers>
  <timer name="auto_map_timer" enabled="n" second="3" offset_second="0.0" send_to="10">
   <send>tc_map</send>
  </timer>
</timers>

<timers>
  <timer name="cd_timer" enabled="n" second="1" offset_second="0.0" send_to="12" script="tcReduceCDs">  
  </timer>
</timers>

<!--  Triggers  -->
<triggers>
  <trigger
   enabled="n"
   group="capture_map_command"
   keep_evaluating="y"
   lines_to_match="2"  
   match="^(?<row>\d) \|\[(?:\s?(?<aWW>\d+)\+\s?(?<aXX>\d+)\s+|\s+)[\| ]?\[(?:\s?(?<bWW>\d+)\+\s?(?<bXX>\d+)\s+|\s+)[\| ]?\[(?:\s?(?<cWW>\d+)\+\s?(?<cXX>\d+)\s+|\s+)\|.*\n\1 \|(?<aObs>\*| )(?:\s?(?<aYY>\d+)\+\s?(?<aZZ>\d+)|\s+)\](?: |\|)(?<bObs>\*| )(?:\s?(?<bYY>\d+)\+\s?(?<bZZ>\d+)|\s+)\](?: |\|)(?<cObs>\*| )(?:\s?(?<cYY>\d+)\+\s?(?<cZZ>\d+)|\s+)\]\|.*\Z"
   multi_line="y"
   regexp="y"
   script="tcHandleMapLine"
   sequence="2"
   omit_from_output="y"
  >
  </trigger>
  <trigger
   enabled="n"
   group="map_command_gag"
   keep_evaluating="y"
   match="^(?<row>\d) \|\[(?:\s?(?<aWW>\d+)\+\s?(?<aXX>\d+)\s+|\s+)[\| ]?\[(?:\s?(?<bWW>\d+)\+\s?(?<bXX>\d+)\s+|\s+)[\| ]?\[(?:\s?(?<cWW>\d+)\+\s?(?<cXX>\d+)\s+|\s+)\|.*$"
   regexp="y"
   script=""
   sequence="2"
   omit_from_output="y"
  >
  <send></send>
  </trigger>
  <trigger
   enabled="n"
   group="map_command_gag"
   keep_evaluating="y"
   match="^(?<row>\d) \|(?<aObs>\*| )(?:\s?(?<aYY>\d+)\+\s?(?<aZZ>\d+)|\s+)\](?: |\|)(?<bObs>\*| )(?:\s?(?<bYY>\d+)\+\s?(?<bZZ>\d+)|\s+)\](?: |\|)(?<cObs>\*| )(?:\s?(?<cYY>\d+)\+\s?(?<cZZ>\d+)|\s+)\]\|.*$"
   regexp="y"
   script=""
   sequence="2"
   omit_from_output="y"
  >
  <send></send>
  </trigger>
  <trigger
   enabled="n"
   group="map_command_gag"
   keep_evaluating="y"
   match="^\s+-----------------------\s*(?:Key: \[WW\+XX\s?)?$"
   regexp="y"
   script=""
   sequence="2"
   omit_from_output="y"
  >
  <send></send>
  </trigger>
  <trigger
   enabled="n"
   group="map_command_gag"
   keep_evaluating="y"
   match="^\s+A       B       C\s?$"
   regexp="y"
   script="tcHandleMapEnd"
   sequence="2"
   omit_from_output="y"
  >
  <send></send>
  </trigger>
  <trigger
   enabled="n"
   group="wait_for_observe_start"
   keep_evaluating="y"
   match="^tc_observe_start$"
   regexp="y"
   script="tcHandleObserveStart"
   sequence="2"
   omit_from_output="y"
  >
  </trigger>
  <trigger
   enabled="n"
   group="capture_observe"
   keep_evaluating="y"
   match="^An Angelic (?<name>\w+) \[(?<hp>\d+)%\] is (?:standing there\.|fighting \w+ .*)$"
   regexp="y"
   script="tcHandleObserveEnemyLine"
   sequence="2"
   omit_from_output="n"
  >
  </trigger>
  <trigger
   enabled="n"
   group="capture_observe"
   keep_evaluating="y"
   match="^An Archangel (?<name>Commander) \[(?<hp>\d+)%\] is (?:standing there\.|fighting \w+ .*)$"
   regexp="y"
   script="tcHandleObserveEnemyLine"
   sequence="2"
   omit_from_output="n"
  >
  </trigger>
  <trigger
   enabled="n"
   group="capture_observe"
   keep_evaluating="y"
   match="^A (?<name>Seraph) \[(?<hp>\d+)%\] is (?:standing there\.|fighting \w+ .*)$"
   regexp="y"
   script="tcHandleObserveEnemyLine"
   sequence="2"
   omit_from_output="n"
  >
  </trigger>
  <trigger
   enabled="n"
   group="capture_observe"
   keep_evaluating="y"
   match="^(?<name>\w+) \[(?<hp>\d+)%\] is (?:standing there\.|fighting \w+ .*)$"
   regexp="y"
   script="tcHandleObservePlayerLine"
   sequence="2"
   omit_from_output="n"
  >
  </trigger>
  <trigger
   enabled="n"
   group="capture_observe"
   keep_evaluating="y"
   match="^tc_observe_end(?: (?<action>.*)|)$"
   regexp="y"
   script="tcHandleObserveEnd"
   sequence="2"
   omit_from_output="y"
  >
  </trigger>
  <trigger
   name = "acid"
   enabled="n"
   group="tc_capture_cds"
   keep_evaluating="y"
   match="^You see acid begin to flood out from room (?<col>[a-c])(?<row>\d).$"
   regexp="y"
   script="tcHandleCDStart"
   sequence="2"
   omit_from_output="n"
  >
  </trigger>
  <trigger
   name = "water"
   enabled="n"
   group="tc_capture_cds"
   keep_evaluating="y"
   match="^You see a healing geyser erupt at room (?<col>[a-c])(?<row>\d).$"
   regexp="y"
   script="tcHandleCDStart"
   sequence="2"
   omit_from_output="n"
  >
  </trigger>
  <trigger
   name = "lightning"
   enabled="n"
   group="tc_capture_cds"
   keep_evaluating="y"
   match="^You see lightning strike room (?<col>[a-c])(?<row>\d).$"
   regexp="y"
   script="tcHandleCDStart"
   sequence="2"
   omit_from_output="n"
  >
  </trigger>
</triggers>

<!--  Script  -->

<script>
<![CDATA[
require "var"
require "serialize"
require "themed_miniwindows"
require "tprint"
require "copytable"
require "wait"
dofile(GetInfo(60) .. "aardwolf_colors.lua")

local tc_options = {}
local map = {}
local map_in_progress = {}
local window = nil
local font = nil
local tc_enabled = false
local tc_observed = {}

function tcGetDefaultOptions()
  local default_options = {
    auto_map = {
      enabled = true,
      period = 3,
      gag_output = true,
    },
    style = {
      cells_offset_left = 20,
      text_padding = 3,
      text_cell_line_padding = 10,
      cell_padding_x = 4,
      cell_padding_y = 4,
      cell_conn_width = 20,
      cell_conn_height = 15,
      -- BGR
      text_color = 0xc8c8c8,
      bg_color = 0x333333,
      ww_color = 0x00ffff,
      xx_color = 0x0000ff,
      xx_border_color = 0x0000ff,
      yy_color = 0x00ff00,
      zz_color = 0xff4444,
      obs_color = 0xEE00EE,
    },
    font = {
      name = "Courier",
      size = 10,
      bold = true,
    },
    mouse_actions = {
      ["right"] = "tc_observe %col%row",
      ["shift+right"] = "tc_report_players tc_gt %col%row",
      ["alt+right"] = "tc_report_bad tc_gt %col%row",
      ["middle"] = "tc_gt advance @M%rowN",
      ["alt+middle"] = "tc_report_cd tc_gt",
      ["left"] = "acid %col%row",
      ["shift+left"] = "water %col%row",
      ["alt+left"] = "lightning %col%row",
    },
    misc = {
      group_tell_prefix = "@w[@BE@RP@GI@YC @RTC@w] =>@Y",
      show_health_in_cells = true,
      observe_data_validity = 5,
    },
  }
  return default_options
end

function tcCheckOptions()
  if tc_options.misc == nil then
    tc_options.misc = {}
    tc_options[misc][group_tell_prefix] = tcGetDefaultOptions().misc.group_tell_prefix
  end
  if tc_options.misc.tc_auto_report_bad_cmd ~= nil then
    tc_options.misc.tc_auto_report_bad_cmd = nil
  end
  if tc_options.misc.observe_data_validity == nil then
    tc_options.misc.observe_data_validity = tcGetDefaultOptions().misc.observe_data_validity
  end
  if tc_options.misc.observe_data_validity < 1 then
    tc_options.misc.observe_data_validity = 1
  end
end

function tcLoadOptions()
  tc_options = loadstring(string.format("return %s", var.config or serialize.save_simple(tcGetDefaultOptions())))()
  tcCheckOptions()
  tcSaveOptions()
end

function tcSaveOptions()
  var.config = serialize.save_simple(tc_options)
end

------ Cooldowns ------

local tc_cooldowns = {
  water = {
    max = 10,
    current = 0,
    name = "@BWater@W"
  },
  acid = {
    max = 30,
    current = 0,
    name = "@gAcid@W"
  },
  lightning = {
    max = 30,
    current = 0,
    name = "@CLightning@W"
  },
}

function tcExecuteReportCD(channel)
  local message = "CDs:"
  for _, val in pairs(tc_cooldowns) do
    local text = val.current == 0 and "@GREADY" or "@R"..tostring(val.current).."s"
    text = val.name..":"..text
    message = message.." "..text
  end
  Execute(channel.." "..message)
end

function tcExecuteAction(name, row, col)
  Execute("say "..name.." "..col..row)
end

function tcHandleCDStart(name, line, wildcards)
  tc_cooldowns[name].current = tc_cooldowns[name].max
  tcShowWindow()
end

function tcReduceCDs()
  for _, val in pairs(tc_cooldowns) do
    val.current = math.max(val.current - 1, 0)
  end
  tcShowWindow()
end

------ Map related code ------

function tcExecuteMapCommand()
  map_in_progress = {}
  EnableTriggerGroup("capture_map_command", 1)
  EnableTriggerGroup("map_command_gag", tc_options.auto_map.gag_output)
  SendNoEcho("map")
end

function tcHandleMapLine(name, line, wildcards)
  local row = {}
  row[1] = { observed = wildcards.aObs == "*" or false,
             WW = wildcards.aWW,
             XX = wildcards.aXX,
             YY = wildcards.aYY,
             ZZ = wildcards.aZZ,
           }
  row[2] = { observed = wildcards.bObs == "*" or false,
             WW = wildcards.bWW,
             XX = wildcards.bXX,
             YY = wildcards.bYY,
             ZZ = wildcards.bZZ,
           }
  row[3] = { observed = wildcards.cObs == "*" or false,
             WW = wildcards.cWW,
             XX = wildcards.cXX,
             YY = wildcards.cYY,
             ZZ = wildcards.cZZ,
           }
  map_in_progress[tonumber(wildcards.row)] = row
end

function tcHandleMapEnd(name, line, wildcards)
  EnableTriggerGroup("capture_map_command", 0)
  EnableTriggerGroup("map_command_gag", 0)

  map = copytable.deep(map_in_progress)

  -- clear observed results if there're no more bad mobs/players in map display
  for row = 0, 9, 1 do
    local arow = tostring(row)
    if tc_observed[arow] ~= nil then
      for col = 1, 3, 1 do
        local acol = col == 1 and "a" or (col == 2 and "b" or "c")
        if tc_observed[arow][acol] ~= nil then
          if map[row][col].XX == "" or map[row][col].XX == "0" then
            tc_observed[arow][acol].mobs = {}
          end
          if map[row][col].YY == "" or map[row][col].YY == "0" then
            tc_observed[arow][acol].players = {}
          end
        end
      end
    end
  end

  tcShowWindow()
end

------ Observe related code ------

local tc_bad_mobs = {
  ["Enchanter"] = "@REnchanter@Y",
  ["Immolator"] = "@RImmolator@Y",
  ["Commander"] = "@RCommander@Y",
  ["Seraph"] = "@RSeraph@Y",
  ["Vanquisher"] = "@RVanquisher@Y",
  ["Eliminator"] = "@REliminator@Y",
}
local tc_observing = false
local tc_col = nil
local tc_row = nil

function tcEcexuteObserveCmd(row, col, action)
  if tc_observing then
    Note("observe command queued already, ignoring")
  end
  tc_observing = true
  tc_row = row
  tc_col = col -- == "a" and 1 or (col == "b" and 2 or 3)
  if tc_observed[tc_row] == nil then
    tc_observed[tc_row] = {}
  end
  tc_observed[tc_row][tc_col] = {mobs={}, players={}}
  tc_observed[tc_row][tc_col].timestamp = os.time()
  EnableTriggerGroup("wait_for_observe_start", 1)
  SendNoEcho("echo tc_observe_start")
  Execute("observe "..col..row)
  SendNoEcho("echo tc_observe_end"..(action == nil and "" or " "..action))
end

function tcHandleObserveStart()
  EnableTriggerGroup("wait_for_observe_start", 0)
  EnableTriggerGroup("capture_observe", 1)
end

function tcHandleObserveEnd(name, line, wildcards)
  EnableTriggerGroup("capture_observe", 0)
  tc_observing = false
  Execute("tc_report_bad echo "..tc_col..tc_row)
  Execute("tc_report_players echo "..tc_col..tc_row) 
  if wildcards.action ~= "" then
    Execute(wildcards.action)
  end
  if tc_options.misc.show_health_in_cells then
    tcShowWindow()
  end
end

function tcHandleObserveEnemyLine(name, line, wildcards)
  --Note("enemy "..wildcards.name.." "..wildcards.hp)
  local t = {
    name = wildcards.name,
    hp = tonumber(wildcards.hp)
  }
  table.insert(tc_observed[tc_row][tc_col].mobs, t)
end

function tcHandleObservePlayerLine(name, line, wildcards)
  local t = {
    name = wildcards.name,
    hp = tonumber(wildcards.hp)
  }
  table.insert(tc_observed[tc_row][tc_col].players, t)
end

function tcGetBadHealth(row, col)
  if tc_observed[row] == nil or tc_observed[row][col] == nil then
    return 0
  end

  local count = 0
  local hp = 0
  for i = 1, #tc_observed[row][col].mobs, 1 do
    if tc_bad_mobs[tc_observed[row][col].mobs[i].name] ~= nil then
      count = count + 1
      hp = hp + tc_observed[row][col].mobs[i].hp
    end
  end

  return count > 0 and math.ceil(hp / count) or 0
end

function tcGetPlayerHealth(row, col)
  if tc_observed[row] == nil or tc_observed[row][col] == nil then
    return 0
  end

  local count = 0
  local hp = 0
  for i = 1, #tc_observed[row][col].players, 1 do
    count = count + 1
    hp = hp + tc_observed[row][col].players[i].hp
  end

  return count > 0 and math.ceil(hp / count) or 0
end

function tcExecuteReportBad(channel, row, col)
  if tc_observed[row] == nil or tc_observed[row][col] == nil or 
     (os.time() - tc_observed[tc_row][tc_col].timestamp) > tc_options.misc.observe_data_validity then
    tcEcexuteObserveCmd(row, col, "tc_report_bad "..channel.." "..col..row)
    return
  end

  local message = ""
  for i = 1, #tc_observed[row][col].mobs, 1 do
    local name = tc_bad_mobs[tc_observed[row][col].mobs[i].name]
    if name ~= nil then
      if message ~= "" then message = message.." " end
      message = message..name.."@W["..tc_observed[row][col].mobs[i].hp.."%]"
    end
  end
  if message ~= "" then
    message = message.." in @M"..string.upper(col)..row
    Execute(channel.." "..message)
  end
end

function tcExecuteReportPlayers(channel, row, col)
  if tc_observed[row] == nil or tc_observed[row][col] == nil or 
     (os.time() - tc_observed[tc_row][tc_col].timestamp) > tc_options.misc.observe_data_validity then
    tcEcexuteObserveCmd(row, col, "tc_report_players "..channel.." "..col..row)
    return
  end

  if #tc_observed[row][col].players > 0 then
    local message = "@G"..tostring(#tc_observed[row][col].players).."@W Players with average @G"..
                    tostring(tcGetPlayerHealth(row, col)).."@W% HP in @M"..string.upper(col)..row
    Execute(channel.." "..message)
  end
end

------ Window functions ------

function tcGetCellSize()
  --local font = WindowFontList(window.id)[1]
  local max_text = "88  88"
  return WindowTextWidth(window.id, font, max_text, false) + 2 * tc_options.style.text_padding,
         2 * WindowFontInfo(window.id, font, 1) +
         2 * tc_options.style.text_padding + tc_options.style.text_cell_line_padding
end

function tcDrawCell(row, col)
  --local font = WindowFontList(window.id)[1]
  local width, height = tcGetCellSize()
  local left = window.bodyleft + tc_options.style.cells_offset_left +
               tc_options.style.cell_padding_x * (col -1) + width * (col - 1)
  local top = window.bodytop + tc_options.style.cell_padding_y * (9 - row) + height * (9 - row)
  local right = left + width
  local bottom = top + height

  -- Draw rect  
  WindowRectOp(window.id, 2, left + 1, top + 1, right - 1, bottom - 1, tc_options.style.bg_color)
  local outline_color = (map[row][col].XX ~= "" and map[row][col].XX ~= "0")
                        and tc_options.style.xx_border_color or tc_options.style.text_color
  WindowRectOp(window.id, 1, left, top, right, bottom, outline_color)

  -- Draw text
  if map[row][col].WW ~= "0" then
    WindowText(window.id, font, map[row][col].WW, left + tc_options.style.text_padding,
               top + tc_options.style.text_padding,
               right, bottom, tc_options.style.ww_color, false)
  end

  if map[row][col].XX ~= "0" then
    local text_width = WindowTextWidth(window.id, font, map[row][col].XX, false)
    WindowText(window.id, font, map[row][col].XX, 
               right - tc_options.style.text_padding - text_width,
               top + tc_options.style.text_padding,
               right, bottom, tc_options.style.xx_color, false)
  end

  if map[row][col].YY ~= "0" then
    WindowText(window.id, font, map[row][col].YY, left + tc_options.style.text_padding,
               top + tc_options.style.text_padding + WindowFontInfo(window.id, font, 1) +
                 tc_options.style.text_cell_line_padding,
               right, bottom, tc_options.style.yy_color, false)
  end

  if map[row][col].ZZ ~= "0" then
    local text_width = WindowTextWidth(window.id, font, map[row][col].ZZ, false)
    WindowText(window.id, font, map[row][col].ZZ, right - tc_options.style.text_padding - text_width,
               top + tc_options.style.text_padding + WindowFontInfo(window.id, font, 1) +
                 tc_options.style.text_cell_line_padding,
               right, bottom, tc_options.style.zz_color, false)
  end

  -- Draw health bars
  if tc_options.misc.show_health_in_cells then
    local arow = tostring(row)
    local acol = col == 1 and "a" or (col == 2 and "b" or "c")
    local bh = tcGetBadHealth(arow, acol)
    local ph = tcGetPlayerHealth(arow, acol)
    local aleft = left+tc_options.style.text_padding
    local aright = right-tc_options.style.text_padding
    local atop = top + tc_options.style.text_padding + WindowFontInfo(window.id, font, 1) + 1

    WindowRectOp(window.id, 1, aleft, atop, aleft + (aright - aleft) * (bh / 100),
                 atop + 2, tc_options.style.xx_color)
    WindowRectOp(window.id, 1, aleft, atop + 3, aleft + (aright - aleft) * (ph / 100),
                 atop + 5, tc_options.style.yy_color)
  end

  if map[row][col].observed then
    local text_width = WindowTextWidth(window.id, font, "*", false)
    WindowText(window.id, font, "*", left + (width - text_width) / 2,
               top + (height - WindowFontInfo(window.id, font, 1)) / 2,
               right, bottom, tc_options.style.obs_color, false)
  end
end

function tcGetTooltip()
  result = ""
  for key, val in pairs(tc_options.mouse_actions) do
    if result ~= "" then
      result = result.."\n"
    end
    result = result..key.." click => "..val
  end
  return result
end

function tcDrawStatic()
  local width, height = tcGetCellSize()
  local max_height = 0

  for row = 0, 9, 1 do
    local top = window.bodytop + tc_options.style.cell_padding_y * (9 - row) + height * (9 - row)
    local bottom = top + height

    -- Draw row number
    local text_width = WindowTextWidth(window.id, font, tostring(row), false)
    WindowText(window.id, font, tostring(row), window.bodyleft + (tc_options.style.cells_offset_left - text_width) / 2,
               top + (height - WindowFontInfo(window.id, font, 1)) / 2,
               window.bodyleft + (tc_options.style.cells_offset_left + text_width) / 2,
               top + (height + WindowFontInfo(window.id, font, 1)) / 2, tc_options.style.text_color, false)

    for col = 1, 3, 1 do
      local left = window.bodyleft + tc_options.style.cells_offset_left +
                   tc_options.style.cell_padding_x * (col -1) + width * (col - 1)
      local right = left + width

      -- Draw connections to next cells
      if col ~= 3 and (row == 9 or row == 7 or row == 4 or row == 0) then
        WindowRectOp(window.id, 2, right - 1, top + (height - tc_options.style.cell_conn_height) / 2,
                     right + tc_options.style.cell_padding_x + 1,
                     top + (height + tc_options.style.cell_conn_height) / 2, tc_options.style.bg_color)
      end
      if row ~= 0 then
        WindowRectOp(window.id, 2, left + (width - tc_options.style.cell_conn_width) / 2, bottom - 1,
                     left + (width + tc_options.style.cell_conn_width) / 2,
                     bottom + tc_options.style.cell_padding_y + 1, tc_options.style.bg_color)
      end

      -- Draw col number
      if row == 0 then
        local text = col == 1 and "A" or (col == 2 and "B" or "C")
        local text_width = WindowTextWidth(window.id, font, text, false)
        max_height = bottom + tc_options.style.text_padding + WindowFontInfo(window.id, font, 1)
        WindowText(window.id, font, text, left + (width - text_width) / 2, bottom + tc_options.style.text_padding,
                   left + (width + text_width) / 2, max_height, tc_options.style.text_color, false)
      end

      -- Add/move hotspots
      cell_id = (col == 1 and "a" or (col == 2 and "b" or "c")) .. tostring(row)
      if WindowMoveHotspot(window.id, cell_id, left, top, right, bottom) ~= 0 then
        WindowAddHotspot(window.id, cell_id, left, top, right, bottom,
                         nil, nil, nil, nil, "tcOnCellMouseUp",
                         tcGetTooltip(),
                         miniwin.cursor_plus, -- cursor
                         0  -- flags
                        )
      end
    end
  end
  return max_height
end

function tcWindowRedraw()
  window:blank()
  for row = 0, 9, 1 do
    for col = 1, 3, 1 do
      if map[row] ~= nil and map[row][col] ~= nil then
        tcDrawCell(row, col)
      end
    end
  end

  local top = tcDrawStatic() + tc_options.style.text_padding
  local text_height = WindowFontInfo(window.id, font, 1)
  local left = window.bodyleft + tc_options.style.text_padding

  -- Draw cooldowns
  for _, val in pairs(tc_cooldowns) do
    local text = val.current == 0 and "@GREADY" or "@R"..tostring(val.current).."s"
    text = val.name..": "..text
    local text_width = WindowTextWidth(window.id, font, strip_colours(text), false)
    local styles = ColoursToStyles(text, tc_options.style.text_color, tc_options.style.bg_color, false, false)
    Theme.WindowTextFromStyles(window.id, font, styles, left, top, left + text_width, top + text_height, false)
    top = top + text_height + tc_options.style.text_padding
  end

  window:dress_window()
end

function tcShowWindow()
  if window == nil then
    window = ThemedBasicWindow("tcWindow", 100, 100, 223, 550, "TC", "center", true, 1, tcWindowRedraw, tcWindowRedraw, tcOnWindowDelete)
    font = "tc_font"
    WindowFont(window.id, font, tc_options.font.name, tc_options.font.size, tc_options.font.bold,
               false, false, false, 0, 0)  -- bold
  end
  tcWindowRedraw()
  window:show()
end

function tcOnWindowDelete()
  window = nil
  font = nil
end

function tcOnCellMouseUp(flags, hotspot_id)
  if (tc_options.mouse_actions[tcMouseFlagsToName(flags)] ~= nil) then
    local action = tc_options.mouse_actions[tcMouseFlagsToName(flags)]
    action = string.gsub(action, "%%col", string.sub(hotspot_id, 1, 1))
    action = string.gsub(action, "%%row", string.sub(hotspot_id, 2, 2))
    Execute(action)
  else
    Note("Warn: no action assigned for "..tcMouseFlagsToName(flags).. " click")
  end
end

------ Mouse buttons helpers -------

function tcMouseFlagsToName(flags)
  local result = ""
  if bit.band(flags, miniwin.hotspot_got_control) ~= 0 then
    result = result.."ctrl+"
  end
  if bit.band(flags, miniwin.hotspot_got_alt) ~= 0 then
    result = result.."alt+"
  end
  if bit.band(flags, miniwin.hotspot_got_shift) ~= 0 then
    result = result.."shift+"
  end
  if bit.band(flags, miniwin.hotspot_got_lh_mouse) ~= 0 then
    result = result.."left"
  end
  if bit.band(flags, miniwin.hotspot_got_rh_mouse) ~= 0 then
    result = result.."right"
  end
  if bit.band(flags, miniwin.hotspot_got_middle_mouse) ~= 0 then
    result = result.."middle"
  end
  return result
end

function tcNameToMouseFlags(name)
  local result = 0
  local re = rex.new("^(?<ctrl>ctrl\\+)?(?<alt>alt\\+)?(?<shift>shift\\+)?(?<button>left|right|middle)$")
  local s, e, captures = re:match(name)
  if s ~= nil then
    result = result + (captures.ctrl and miniwin.hotspot_got_control or 0)
    result = result + (captures.alt and miniwin.hotspot_got_alt or 0)
    result = result + (captures.shift and miniwin.hotspot_got_shift or 0)
    result = result + (captures.button == "left" and miniwin.hotspot_got_lh_mouse or 0)
    result = result + (captures.button == "right" and miniwin.hotspot_got_rh_mouse or 0)
    result = result + (captures.button == "middle" and miniwin.hotspot_got_middle_mouse or 0)
  else
    Note("Warn: incorrect mouse flags ["..name.."]")
  end
  return result
end

------ Console commands ------

function tcOnMapCmd()
  tcExecuteMapCommand()
end

function tcOnShowCmd()
  tcShowWindow()
end

function tcOnOffCmd()
  tc_enabled = false
  SetTimerOption("auto_map_timer", "enabled", false)
  SetTimerOption("cd_timer", "enabled", false)
  EnableAliasGroup("tc_actions", false)
  EnableTriggerGroup("tc_capture_cds", false)
  if window then window:delete(false) end
end

function tcOnOnCmd()
  tc_enabled = on
  if tc_options.auto_map.enabled then
    SetTimerOption("auto_map_timer", "second", tc_options.auto_map.period)
    SetTimerOption("auto_map_timer", "enabled", true)
  end
  SetTimerOption("cd_timer", "enabled", true)
  EnableAliasGroup("tc_actions", true)
  EnableTriggerGroup("tc_capture_cds", true)
  tcShowWindow()
end

function tcOnOptionsCmd(name, line, wildcards)
  Note("TC Options:")
  if wildcards.key1 == "" then
    tprint(tc_options)
    return
  end

  if tc_options[wildcards.key1] == nil then
    Note("Warn: unknown option group "..wildcards.key1)
    return
  end
  if wildcards.key1 == "mouse_actions" then
    if tcNameToMouseFlags(wildcards.key2) == 0 then
      Note("Warn: unknown mouse action "..wildcards.key2)
      return
    end
  elseif tc_options[wildcards.key1][wildcards.key2] == nil then
    Note("Warn: unknown option "..wildcards.key2)
    return
  end

  local type = wildcards.key1 == "mouse_actions" and "string" or type(tc_options[wildcards.key1][wildcards.key2])

  if type == "boolean" then
    local bool = wildcards.value == "true" and true or nil
    if wildcards.value == "false" then
      bool = false
    end
    if bool ~= nil then
      tc_options[wildcards.key1][wildcards.key2] = bool
      tcCheckOptions()
      tcSaveOptions()
      Note("Set "..wildcards.key1.." "..wildcards.key2.." to "..tostring(tc_options[wildcards.key1][wildcards.key2]))
    else
      Note(wildcards.value.." is not a valid boolean")
    end
  elseif type == "number" then
    if tonumber(wildcards.value) ~= nil then
      tc_options[wildcards.key1][wildcards.key2] = tonumber(wildcards.value)
      tcCheckOptions()
      tcSaveOptions()
      Note("Set "..wildcards.key1.." "..wildcards.key2.." to "..tostring(tc_options[wildcards.key1][wildcards.key2]))
    else
      Note(wildcards.value.." is not a valid number")
    end
  elseif type == "string" then
    if wildcards.key1 == "mouse_actions" and wildcards.value == "clear" then
      wildcards.value = nil
    end
    tc_options[wildcards.key1][wildcards.key2] = wildcards.value
    tcCheckOptions()
    tcSaveOptions()
    Note("Set "..wildcards.key1.." "..wildcards.key2.." to "..tostring(tc_options[wildcards.key1][wildcards.key2]))
  else
    Note("Warn: unexpected value type "..type)
  end

  if wildcards.key1 == "font" or wildcards.key1 == "style" or wildcards.key1 == "mouse_actions" then
    if window then window:delete(false) end
    tcShowWindow()
  elseif wildcards.key1 == "auto_map" then
    if tc_enabled then
      tcOnOnCmd()
    end
  end
end

function tcOnOptionsResetCmd()
  tc_options = copytable.deep(tcGetDefaultOptions())
  tcSaveOptions()
  if window then window:delete(false) end
  tcShowWindow()
end

function tcOnGtCmd(name, line, wildcards)
  SendNoEcho("gtell "..tc_options.misc.group_tell_prefix..wildcards.message)
end

function tcOnObserveCmd(name, line, wildcards)
  tcEcexuteObserveCmd(wildcards.row, wildcards.col)
end

function tcOnReportBadCmd(name, line, wildcards)
  tcExecuteReportBad(wildcards.channel, wildcards.row, wildcards.col)
end

function tcOnReportPlayersCmd(name, line, wildcards)
  tcExecuteReportPlayers(wildcards.channel, wildcards.row, wildcards.col)
end

function tcOnReportCDCmd(name, line, wildcards)
  tcExecuteReportCD(wildcards.channel)
end

function tcOnActionCmd(name, line, wildcards)
  tcExecuteAction(name, wildcards.row, wildcards.col)
end

function tcOnTestCmd()
  local test = [[
   -----------------------  Key: [WW+XX
9 |[ 4+ 0  [ 4+ 0  [ 4+ 0 |      YY+ZZ ]
9 |      ]       ]       ]| WW: Angel soldiers
8 |[ 4+ 0 |[ 4+ 0 |[ 4+ 0 | XX: Others
8 |      ]|      ]|      ]| YY: Players
7 |[ 5+ 0  [10+ 0  [ 6+ 0 | ZZ: Titans
7 |      ]       ]       ]|  * You can observe a room
6 |[ 4+ 1 |[ 4+ 0 |[ 4+ 0 |
6 |  1+ 0]|      ]|      ]|
5 |[ 4+ 0 |[      |[ 4+ 0 |
5 |  7+ 1]|  5+ 0]|  7+ 5]|
4 |[       [       [      |
4 |      ] * 1+ 1]       ]|
3 |[      |[      |[      |
3 |  0+ 3]|  0+ 3]|  0+ 3]|
2 |[      |[      |[      |
2 |      ]|      ]|      ]|
1 |[12+13 |[      |[      |
1 | 10+15]|      ]|      ]|
0 |[       [       [      |
0 |      ]       ]       ]|
   -----------------------
      A       B       C
]]
  tcShowWindow()
  Execute("tc_map")
  wait.make(function()
    wait.time(1.5)
    Simulate(test)
  end)
end

function tcOnTestObserveCmd(name, line, wildcards)
  local test = [[
tc_observe_start
You see:
An Angelic Guardian [100%] is standing there.
An Angelic Destroyer [100%] is standing there.
A Warrior-Angel [0%] is standing there.
The Gate [92%] is standing there.
An Angelic Enchanter [100%] is standing there.
An Angelic Immolator [100%] is standing there.
An Angelic Enchanter [90%] is standing there.
An Archangel Commander [26%] is fighting Sletch [5%]!
A Seraph [100%] is standing there.
An Angelic Vanquisher [100%] is standing there.
Sletch [5%] is fighting an Archangel Commander [26%]!
Athlau [100%] is standing there.
tc_observe_end
]]
  tcShowWindow()
  Execute("tc_observe "..wildcards.col..wildcards.row)
  Simulate(test)
end

function tcOnTestCdCmd(name, line, wildcards)
  local test = [[
You see acid begin to flood out from room b7.
You see a healing geyser erupt at room a9.
You see lightning strike room a9!
]]
  Execute("tc_on")
  Simulate(test)
end

------ Plugin Callbacks ------

function tcOnHelp()
  world.Note(world.GetPluginInfo(world.GetPluginID(), 3))
end

function OnPluginInstall()
  tcOnHelp()
  OnPluginEnable()
end

function OnPluginEnable()
  tcLoadOptions()
  tcShowWindow()
end

function OnPluginConnect()
  tcLoadOptions()
end

function OnPluginDisable()
end

function OnPluginSaveState()
  tcSaveOptions()
end
]]>
</script>

</muclient>
